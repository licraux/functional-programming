module test
// 6.1 (HR 6.2)
type Fexpr = 
    | Const of float
    | X
    | Add of Fexpr * Fexpr
    | Sub of Fexpr * Fexpr
    | Mul of Fexpr * Fexpr
    | Div of Fexpr * Fexpr
    | Sin of Fexpr
    | Cos of Fexpr
    | Log of Fexpr
    | Exp of Fexpr;;

let rec fexprToString (expr: Fexpr) : string =
    match expr with
    | Const x ->  x.ToString() 
    | X -> "X"
    | Add (e1, e2) -> fexprToString e1 + " " +  fexprToString e2 + " " + "+"
    | Sub (e1, e2) -> fexprToString e1 + " " + fexprToString e2 + " " + "-"
    | Mul (e1, e2) -> fexprToString e1 + " " + fexprToString e2 + " " +  "*"
    | Div (e1, e2) -> fexprToString e1 + " " + fexprToString e2 + " " + "/"
    | Sin e -> fexprToString e + " sin"
    | Cos e -> fexprToString e + " cos"
    | Log e -> fexprToString e + " log"
    | Exp e -> fexprToString e + " exp"

//sample test
let expr = Mul (Add (X, Const 7.0), Sub (X, Const 5.0)) 


// 6.2 (HR 6.8)

type Stack = S of float list

type Instruction = | ADD | SUB | MULT | DIV | SIN
                   | COS | LOG | EXP | PUSH of float


let intpInstr (stack: Stack) (instr: Instruction) : Stack =
    match instr with
    | ADD -> 
        match stack with
        | S (a::b::t) -> S ((b + a)::t)
        | _ -> failwith "Not enough elements on the stack"
    | SUB -> 
        match stack with
        | S (a::b::t) -> S ((b - a)::t)
        | _ -> failwith "Not enough elements on the stack"
    | MULT -> 
        match stack with
        | S (a::b::t) -> S ((b * a)::t)
        | _ -> failwith "Not enough elements on the stack"
    | DIV -> 
        match stack with
        | S (a::b::t) -> S ((b / a)::t)
        | _ -> failwith "Not enough elements on the stack"
    | SIN -> 
        match stack with
        | S (a::t) -> S (sin a :: t)
        | _ -> failwith "Not enough elements on the stack"
    | COS -> 
        match stack with
        | S (a::t) -> S (cos a :: t)
        | _ -> failwith "Not enough elements on the stack"
    | LOG -> 
        match stack with
        | S (a::t) -> S (log a :: t)
        | _ -> failwith "Not enough elements on the stack"
    | EXP -> 
        match stack with
        | S (a::t) -> S (exp a :: t)
        | _ -> failwith "Not enough elements on the stack"
    | PUSH r -> S (r :: (match stack with S s -> s))


//Creates an empty stack to begin with. Then, it executes each instruction in the list in order and finally it gets the top value of the final stack
//if there's any.
let intpProg (instr: Instruction list) : float =
    let stack = S []
    let finalStack = List.fold (fun acc instr -> intpInstr acc instr) stack instr
    match finalStack with
    | S (x::_) -> x
    | _ -> failwith "Empty stack"

//Creates or translates a tuple which contains an expression and a float to an instruction list in postsfix form. 
//This Instruction list output generated by the trans function can then be inserted in the intpProg function to calculate the final value
//based on the execution of expressions. Essentially, trans(fe, x) is a program prg that can be fed as an input argument to the intpProg function
//which takes an Instruction list as a parameter. 
let trans (expr: Fexpr, flt: float) : Instruction list =
    let rec toPostfix expr =
        match expr with
        | Const x -> [PUSH x]
        | X -> [PUSH flt]
        | Add (e1, e2) -> toPostfix e1 @ toPostfix e2 @ [ADD]
        | Sub (e1, e2) -> toPostfix e1 @ toPostfix e2 @ [SUB]
        | Mul (e1, e2) -> toPostfix e1 @ toPostfix e2 @ [MULT]
        | Div (e1, e2) -> toPostfix e1 @ toPostfix e2 @ [DIV]
        | Sin e -> toPostfix e @ [SIN]
        | Cos e -> toPostfix e @ [COS]
        | Log e -> toPostfix e @ [LOG]
        | Exp e -> toPostfix e @ [EXP]
    toPostfix expr


// 6.3 (HR 7.2)
// Signature and implementation files
(* type ComplexNumber =
    static member ( ˜- ) : ComplexNumber -> ComplexNumber
    static member ( + ) : ComplexNumber * ComplexNumber -> ComplexNumber
    static member ( - ) : ComplexNumber * ComplexNumber -> ComplexNumber
    static member ( * ) : ComplexNumber * ComplexNumber -> ComplexNumber
    static member ( / ) : ComplexNumber * ComplexNumber -> ComplexNumber
val make : float * float -> ComplexNumber

(* type ComplexNumber =
    | C of float * float
    static member (˜-) (C(a,b)) = C(-a,-b)
    static member (+) (C(a,b), C(c,d)) = C(a+c, b+d)
    static member (-) (C(a,b), C(c,d)) = C(a-c, b-d)
    static member (*) (C(a,b), C(c,d)) = C(a * c - b * d, a * d + b * c)
    static member (/) (C(a,b), C(c,d)) =
        let denom = (c * c + d * d)
        C((a * c + b * d)/denom, (b * c - a * d) / denom)
let make (a,b) = C(a,b) *) *)
